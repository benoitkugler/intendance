// DON'T EDIT - automatically generated by structgen //

package models

import (
	"database/sql"

	"github.com/lib/pq"
)

type scanner interface {
	Scan(...interface{}) error
}

// DB groups transaction like objects
type DB interface {
	Exec(query string, args ...interface{}) (sql.Result, error)
	Query(query string, args ...interface{}) (*sql.Rows, error)
	QueryRow(query string, args ...interface{}) *sql.Row
	Prepare(query string) (*sql.Stmt, error)
}

func scanOneCommande(row scanner) (Commande, error) {
	var s Commande
	err := row.Scan(
		&s.Id,
		&s.IdUtilisateur,
		&s.DateEmission,
		&s.Tag,
	)
	return s, err
}

func ScanCommande(row *sql.Row) (Commande, error) {
	return scanOneCommande(row)
}

func SelectAllCommandes(tx DB) (Commandes, error) {
	rows, err := tx.Query("SELECT * FROM commandes")
	if err != nil {
		return nil, err
	}
	return ScanCommandes(rows)
}

// SelectCommande returns the entry matching id.
func SelectCommande(tx DB, id int64) (Commande, error) {
	row := tx.QueryRow("SELECT * FROM commandes WHERE id = $1", id)
	return ScanCommande(row)
}

type Commandes map[int64]Commande

func (m Commandes) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanCommandes(rs *sql.Rows) (Commandes, error) {
	var (
		s   Commande
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Commandes, 16)
	for rs.Next() {
		s, err = scanOneCommande(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Commande in the database and returns the item with id filled.
func (item Commande) Insert(tx DB) (out Commande, err error) {
	row := tx.QueryRow(`INSERT INTO commandes (
		id_utilisateur,date_emission,tag
		) VALUES (
		$1,$2,$3
		) RETURNING 
		id,id_utilisateur,date_emission,tag;
		`, item.IdUtilisateur, item.DateEmission, item.Tag)
	return ScanCommande(row)
}

// Update Commande in the database and returns the new version.
func (item Commande) Update(tx DB) (out Commande, err error) {
	row := tx.QueryRow(`UPDATE commandes SET (
		id_utilisateur,date_emission,tag
		) = (
		$2,$3,$4
		) WHERE id = $1 RETURNING 
		id,id_utilisateur,date_emission,tag;
		`, item.Id, item.IdUtilisateur, item.DateEmission, item.Tag)
	return ScanCommande(row)
}

// Deletes the Commande and returns the item
func DeleteCommandeById(tx DB, id int64) (Commande, error) {
	row := tx.QueryRow("DELETE FROM commandes WHERE id = $1 RETURNING *;", id)
	return ScanCommande(row)
}

// Deletes the Commande in the database and returns the ids.
func DeleteCommandesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM commandes WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneCommandeProduit(row scanner) (CommandeProduit, error) {
	var s CommandeProduit
	err := row.Scan(
		&s.IdCommande,
		&s.IdProduit,
		&s.Quantite,
	)
	return s, err
}

func ScanCommandeProduit(row *sql.Row) (CommandeProduit, error) {
	return scanOneCommandeProduit(row)
}

func SelectAllCommandeProduits(tx DB) (CommandeProduits, error) {
	rows, err := tx.Query("SELECT * FROM commande_produits")
	if err != nil {
		return nil, err
	}
	return ScanCommandeProduits(rows)
}

type CommandeProduits []CommandeProduit

func ScanCommandeProduits(rs *sql.Rows) (CommandeProduits, error) {
	var (
		s   CommandeProduit
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(CommandeProduits, 0, 16)
	for rs.Next() {
		s, err = scanOneCommandeProduit(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links CommandeProduit in the database.
func InsertManyCommandeProduits(tx *sql.Tx, items ...CommandeProduit) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("commande_produits",
		"id_commande", "id_produit", "quantite",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdCommande, item.IdProduit, item.Quantite)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link CommandeProduit in the database.
// Only the 'IdCommande' 'IdProduit' fields are used.
func (item CommandeProduit) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM commande_produits WHERE 
	id_commande = $1 AND id_produit = $2;`, item.IdCommande, item.IdProduit)
	return err
}

func scanOneDefautProduit(row scanner) (DefautProduit, error) {
	var s DefautProduit
	err := row.Scan(
		&s.IdUtilisateur,
		&s.IdIngredient,
		&s.IdFournisseur,
		&s.IdProduit,
	)
	return s, err
}

func ScanDefautProduit(row *sql.Row) (DefautProduit, error) {
	return scanOneDefautProduit(row)
}

func SelectAllDefautProduits(tx DB) (DefautProduits, error) {
	rows, err := tx.Query("SELECT * FROM defaut_produits")
	if err != nil {
		return nil, err
	}
	return ScanDefautProduits(rows)
}

type DefautProduits []DefautProduit

func ScanDefautProduits(rs *sql.Rows) (DefautProduits, error) {
	var (
		s   DefautProduit
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(DefautProduits, 0, 16)
	for rs.Next() {
		s, err = scanOneDefautProduit(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links DefautProduit in the database.
func InsertManyDefautProduits(tx *sql.Tx, items ...DefautProduit) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("defaut_produits",
		"id_utilisateur", "id_ingredient", "id_fournisseur", "id_produit",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdUtilisateur, item.IdIngredient, item.IdFournisseur, item.IdProduit)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link DefautProduit in the database.
// Only the 'IdUtilisateur' 'IdIngredient' 'IdFournisseur' 'IdProduit' fields are used.
func (item DefautProduit) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM defaut_produits WHERE 
	id_utilisateur = $1 AND id_ingredient = $2 AND id_fournisseur = $3 AND id_produit = $4;`, item.IdUtilisateur, item.IdIngredient, item.IdFournisseur, item.IdProduit)
	return err
}

func scanOneFournisseur(row scanner) (Fournisseur, error) {
	var s Fournisseur
	err := row.Scan(
		&s.Id,
		&s.Nom,
		&s.Lieu,
	)
	return s, err
}

func ScanFournisseur(row *sql.Row) (Fournisseur, error) {
	return scanOneFournisseur(row)
}

func SelectAllFournisseurs(tx DB) (Fournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM fournisseurs")
	if err != nil {
		return nil, err
	}
	return ScanFournisseurs(rows)
}

// SelectFournisseur returns the entry matching id.
func SelectFournisseur(tx DB, id int64) (Fournisseur, error) {
	row := tx.QueryRow("SELECT * FROM fournisseurs WHERE id = $1", id)
	return ScanFournisseur(row)
}

type Fournisseurs map[int64]Fournisseur

func (m Fournisseurs) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanFournisseurs(rs *sql.Rows) (Fournisseurs, error) {
	var (
		s   Fournisseur
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Fournisseurs, 16)
	for rs.Next() {
		s, err = scanOneFournisseur(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Fournisseur in the database and returns the item with id filled.
func (item Fournisseur) Insert(tx DB) (out Fournisseur, err error) {
	row := tx.QueryRow(`INSERT INTO fournisseurs (
		nom,lieu
		) VALUES (
		$1,$2
		) RETURNING 
		id,nom,lieu;
		`, item.Nom, item.Lieu)
	return ScanFournisseur(row)
}

// Update Fournisseur in the database and returns the new version.
func (item Fournisseur) Update(tx DB) (out Fournisseur, err error) {
	row := tx.QueryRow(`UPDATE fournisseurs SET (
		nom,lieu
		) = (
		$2,$3
		) WHERE id = $1 RETURNING 
		id,nom,lieu;
		`, item.Id, item.Nom, item.Lieu)
	return ScanFournisseur(row)
}

// Deletes the Fournisseur and returns the item
func DeleteFournisseurById(tx DB, id int64) (Fournisseur, error) {
	row := tx.QueryRow("DELETE FROM fournisseurs WHERE id = $1 RETURNING *;", id)
	return ScanFournisseur(row)
}

// Deletes the Fournisseur in the database and returns the ids.
func DeleteFournisseursByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM fournisseurs WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneGroupe(row scanner) (Groupe, error) {
	var s Groupe
	err := row.Scan(
		&s.Id,
		&s.IdSejour,
		&s.Nom,
		&s.NbPersonnes,
		&s.Couleur,
	)
	return s, err
}

func ScanGroupe(row *sql.Row) (Groupe, error) {
	return scanOneGroupe(row)
}

func SelectAllGroupes(tx DB) (Groupes, error) {
	rows, err := tx.Query("SELECT * FROM groupes")
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

// SelectGroupe returns the entry matching id.
func SelectGroupe(tx DB, id int64) (Groupe, error) {
	row := tx.QueryRow("SELECT * FROM groupes WHERE id = $1", id)
	return ScanGroupe(row)
}

type Groupes map[int64]Groupe

func (m Groupes) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanGroupes(rs *sql.Rows) (Groupes, error) {
	var (
		s   Groupe
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Groupes, 16)
	for rs.Next() {
		s, err = scanOneGroupe(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Groupe in the database and returns the item with id filled.
func (item Groupe) Insert(tx DB) (out Groupe, err error) {
	row := tx.QueryRow(`INSERT INTO groupes (
		id_sejour,nom,nb_personnes,couleur
		) VALUES (
		$1,$2,$3,$4
		) RETURNING 
		id,id_sejour,nom,nb_personnes,couleur;
		`, item.IdSejour, item.Nom, item.NbPersonnes, item.Couleur)
	return ScanGroupe(row)
}

// Update Groupe in the database and returns the new version.
func (item Groupe) Update(tx DB) (out Groupe, err error) {
	row := tx.QueryRow(`UPDATE groupes SET (
		id_sejour,nom,nb_personnes,couleur
		) = (
		$2,$3,$4,$5
		) WHERE id = $1 RETURNING 
		id,id_sejour,nom,nb_personnes,couleur;
		`, item.Id, item.IdSejour, item.Nom, item.NbPersonnes, item.Couleur)
	return ScanGroupe(row)
}

// Deletes the Groupe and returns the item
func DeleteGroupeById(tx DB, id int64) (Groupe, error) {
	row := tx.QueryRow("DELETE FROM groupes WHERE id = $1 RETURNING *;", id)
	return ScanGroupe(row)
}

// Deletes the Groupe in the database and returns the ids.
func DeleteGroupesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM groupes WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneIngredient(row scanner) (Ingredient, error) {
	var s Ingredient
	err := row.Scan(
		&s.Id,
		&s.Nom,
		&s.Unite,
		&s.Categorie,
		&s.Callories,
		&s.Conditionnement,
	)
	return s, err
}

func ScanIngredient(row *sql.Row) (Ingredient, error) {
	return scanOneIngredient(row)
}

func SelectAllIngredients(tx DB) (Ingredients, error) {
	rows, err := tx.Query("SELECT * FROM ingredients")
	if err != nil {
		return nil, err
	}
	return ScanIngredients(rows)
}

// SelectIngredient returns the entry matching id.
func SelectIngredient(tx DB, id int64) (Ingredient, error) {
	row := tx.QueryRow("SELECT * FROM ingredients WHERE id = $1", id)
	return ScanIngredient(row)
}

type Ingredients map[int64]Ingredient

func (m Ingredients) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanIngredients(rs *sql.Rows) (Ingredients, error) {
	var (
		s   Ingredient
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Ingredients, 16)
	for rs.Next() {
		s, err = scanOneIngredient(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Ingredient in the database and returns the item with id filled.
func (item Ingredient) Insert(tx DB) (out Ingredient, err error) {
	row := tx.QueryRow(`INSERT INTO ingredients (
		nom,unite,categorie,callories,conditionnement
		) VALUES (
		$1,$2,$3,$4,$5
		) RETURNING 
		id,nom,unite,categorie,callories,conditionnement;
		`, item.Nom, item.Unite, item.Categorie, item.Callories, item.Conditionnement)
	return ScanIngredient(row)
}

// Update Ingredient in the database and returns the new version.
func (item Ingredient) Update(tx DB) (out Ingredient, err error) {
	row := tx.QueryRow(`UPDATE ingredients SET (
		nom,unite,categorie,callories,conditionnement
		) = (
		$2,$3,$4,$5,$6
		) WHERE id = $1 RETURNING 
		id,nom,unite,categorie,callories,conditionnement;
		`, item.Id, item.Nom, item.Unite, item.Categorie, item.Callories, item.Conditionnement)
	return ScanIngredient(row)
}

// Deletes the Ingredient and returns the item
func DeleteIngredientById(tx DB, id int64) (Ingredient, error) {
	row := tx.QueryRow("DELETE FROM ingredients WHERE id = $1 RETURNING *;", id)
	return ScanIngredient(row)
}

// Deletes the Ingredient in the database and returns the ids.
func DeleteIngredientsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM ingredients WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneIngredientProduit(row scanner) (IngredientProduit, error) {
	var s IngredientProduit
	err := row.Scan(
		&s.IdIngredient,
		&s.IdProduit,
		&s.IdUtilisateur,
	)
	return s, err
}

func ScanIngredientProduit(row *sql.Row) (IngredientProduit, error) {
	return scanOneIngredientProduit(row)
}

func SelectAllIngredientProduits(tx DB) (IngredientProduits, error) {
	rows, err := tx.Query("SELECT * FROM ingredient_produits")
	if err != nil {
		return nil, err
	}
	return ScanIngredientProduits(rows)
}

type IngredientProduits []IngredientProduit

func ScanIngredientProduits(rs *sql.Rows) (IngredientProduits, error) {
	var (
		s   IngredientProduit
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(IngredientProduits, 0, 16)
	for rs.Next() {
		s, err = scanOneIngredientProduit(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links IngredientProduit in the database.
func InsertManyIngredientProduits(tx *sql.Tx, items ...IngredientProduit) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("ingredient_produits",
		"id_ingredient", "id_produit", "id_utilisateur",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdIngredient, item.IdProduit, item.IdUtilisateur)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link IngredientProduit in the database.
// Only the 'IdIngredient' 'IdProduit' 'IdUtilisateur' fields are used.
func (item IngredientProduit) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM ingredient_produits WHERE 
	id_ingredient = $1 AND id_produit = $2 AND id_utilisateur = $3;`, item.IdIngredient, item.IdProduit, item.IdUtilisateur)
	return err
}

func scanOneLienIngredient(row scanner) (LienIngredient, error) {
	var s LienIngredient
	err := row.Scan(
		&s.IdIngredient,
		&s.Quantite,
		&s.Cuisson,
	)
	return s, err
}

func ScanLienIngredient(row *sql.Row) (LienIngredient, error) {
	return scanOneLienIngredient(row)
}

func SelectAllLienIngredients(tx DB) (LienIngredients, error) {
	rows, err := tx.Query("SELECT * FROM lien_ingredients")
	if err != nil {
		return nil, err
	}
	return ScanLienIngredients(rows)
}

type LienIngredients []LienIngredient

func ScanLienIngredients(rs *sql.Rows) (LienIngredients, error) {
	var (
		s   LienIngredient
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(LienIngredients, 0, 16)
	for rs.Next() {
		s, err = scanOneLienIngredient(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links LienIngredient in the database.
func InsertManyLienIngredients(tx *sql.Tx, items ...LienIngredient) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("lien_ingredients",
		"id_ingredient", "quantite", "cuisson",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdIngredient, item.Quantite, item.Cuisson)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link LienIngredient in the database.
// Only the 'IdIngredient' fields are used.
func (item LienIngredient) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM lien_ingredients WHERE 
	id_ingredient = $1;`, item.IdIngredient)
	return err
}

func scanOneLivraison(row scanner) (Livraison, error) {
	var s Livraison
	err := row.Scan(
		&s.Id,
		&s.IdFournisseur,
		&s.Nom,
		&s.JoursLivraison,
		&s.DelaiCommande,
		&s.Anticipation,
	)
	return s, err
}

func ScanLivraison(row *sql.Row) (Livraison, error) {
	return scanOneLivraison(row)
}

func SelectAllLivraisons(tx DB) (Livraisons, error) {
	rows, err := tx.Query("SELECT * FROM livraisons")
	if err != nil {
		return nil, err
	}
	return ScanLivraisons(rows)
}

// SelectLivraison returns the entry matching id.
func SelectLivraison(tx DB, id int64) (Livraison, error) {
	row := tx.QueryRow("SELECT * FROM livraisons WHERE id = $1", id)
	return ScanLivraison(row)
}

type Livraisons map[int64]Livraison

func (m Livraisons) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanLivraisons(rs *sql.Rows) (Livraisons, error) {
	var (
		s   Livraison
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Livraisons, 16)
	for rs.Next() {
		s, err = scanOneLivraison(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Livraison in the database and returns the item with id filled.
func (item Livraison) Insert(tx DB) (out Livraison, err error) {
	row := tx.QueryRow(`INSERT INTO livraisons (
		id_fournisseur,nom,jours_livraison,delai_commande,anticipation
		) VALUES (
		$1,$2,$3,$4,$5
		) RETURNING 
		id,id_fournisseur,nom,jours_livraison,delai_commande,anticipation;
		`, item.IdFournisseur, item.Nom, item.JoursLivraison, item.DelaiCommande, item.Anticipation)
	return ScanLivraison(row)
}

// Update Livraison in the database and returns the new version.
func (item Livraison) Update(tx DB) (out Livraison, err error) {
	row := tx.QueryRow(`UPDATE livraisons SET (
		id_fournisseur,nom,jours_livraison,delai_commande,anticipation
		) = (
		$2,$3,$4,$5,$6
		) WHERE id = $1 RETURNING 
		id,id_fournisseur,nom,jours_livraison,delai_commande,anticipation;
		`, item.Id, item.IdFournisseur, item.Nom, item.JoursLivraison, item.DelaiCommande, item.Anticipation)
	return ScanLivraison(row)
}

// Deletes the Livraison and returns the item
func DeleteLivraisonById(tx DB, id int64) (Livraison, error) {
	row := tx.QueryRow("DELETE FROM livraisons WHERE id = $1 RETURNING *;", id)
	return ScanLivraison(row)
}

// Deletes the Livraison in the database and returns the ids.
func DeleteLivraisonsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM livraisons WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneMenu(row scanner) (Menu, error) {
	var s Menu
	err := row.Scan(
		&s.Id,
		&s.IdUtilisateur,
		&s.Commentaire,
	)
	return s, err
}

func ScanMenu(row *sql.Row) (Menu, error) {
	return scanOneMenu(row)
}

func SelectAllMenus(tx DB) (Menus, error) {
	rows, err := tx.Query("SELECT * FROM menus")
	if err != nil {
		return nil, err
	}
	return ScanMenus(rows)
}

// SelectMenu returns the entry matching id.
func SelectMenu(tx DB, id int64) (Menu, error) {
	row := tx.QueryRow("SELECT * FROM menus WHERE id = $1", id)
	return ScanMenu(row)
}

type Menus map[int64]Menu

func (m Menus) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanMenus(rs *sql.Rows) (Menus, error) {
	var (
		s   Menu
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Menus, 16)
	for rs.Next() {
		s, err = scanOneMenu(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Menu in the database and returns the item with id filled.
func (item Menu) Insert(tx DB) (out Menu, err error) {
	row := tx.QueryRow(`INSERT INTO menus (
		id_utilisateur,commentaire
		) VALUES (
		$1,$2
		) RETURNING 
		id,id_utilisateur,commentaire;
		`, item.IdUtilisateur, item.Commentaire)
	return ScanMenu(row)
}

// Update Menu in the database and returns the new version.
func (item Menu) Update(tx DB) (out Menu, err error) {
	row := tx.QueryRow(`UPDATE menus SET (
		id_utilisateur,commentaire
		) = (
		$2,$3
		) WHERE id = $1 RETURNING 
		id,id_utilisateur,commentaire;
		`, item.Id, item.IdUtilisateur, item.Commentaire)
	return ScanMenu(row)
}

// Deletes the Menu and returns the item
func DeleteMenuById(tx DB, id int64) (Menu, error) {
	row := tx.QueryRow("DELETE FROM menus WHERE id = $1 RETURNING *;", id)
	return ScanMenu(row)
}

// Deletes the Menu in the database and returns the ids.
func DeleteMenusByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM menus WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneMenuIngredient(row scanner) (MenuIngredient, error) {
	var s MenuIngredient
	err := row.Scan(
		&s.IdMenu,
		&s.IdIngredient,
		&s.Quantite,
		&s.Cuisson,
	)
	return s, err
}

func ScanMenuIngredient(row *sql.Row) (MenuIngredient, error) {
	return scanOneMenuIngredient(row)
}

func SelectAllMenuIngredients(tx DB) (MenuIngredients, error) {
	rows, err := tx.Query("SELECT * FROM menu_ingredients")
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

type MenuIngredients []MenuIngredient

func ScanMenuIngredients(rs *sql.Rows) (MenuIngredients, error) {
	var (
		s   MenuIngredient
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MenuIngredients, 0, 16)
	for rs.Next() {
		s, err = scanOneMenuIngredient(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MenuIngredient in the database.
func InsertManyMenuIngredients(tx *sql.Tx, items ...MenuIngredient) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("menu_ingredients",
		"id_menu", "id_ingredient", "quantite", "cuisson",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMenu, item.IdIngredient, item.Quantite, item.Cuisson)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MenuIngredient in the database.
// Only the 'IdMenu' 'IdIngredient' fields are used.
func (item MenuIngredient) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM menu_ingredients WHERE 
	id_menu = $1 AND id_ingredient = $2;`, item.IdMenu, item.IdIngredient)
	return err
}

func scanOneMenuRecette(row scanner) (MenuRecette, error) {
	var s MenuRecette
	err := row.Scan(
		&s.IdMenu,
		&s.IdRecette,
	)
	return s, err
}

func ScanMenuRecette(row *sql.Row) (MenuRecette, error) {
	return scanOneMenuRecette(row)
}

func SelectAllMenuRecettes(tx DB) (MenuRecettes, error) {
	rows, err := tx.Query("SELECT * FROM menu_recettes")
	if err != nil {
		return nil, err
	}
	return ScanMenuRecettes(rows)
}

type MenuRecettes []MenuRecette

func ScanMenuRecettes(rs *sql.Rows) (MenuRecettes, error) {
	var (
		s   MenuRecette
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(MenuRecettes, 0, 16)
	for rs.Next() {
		s, err = scanOneMenuRecette(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links MenuRecette in the database.
func InsertManyMenuRecettes(tx *sql.Tx, items ...MenuRecette) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("menu_recettes",
		"id_menu", "id_recette",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdMenu, item.IdRecette)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link MenuRecette in the database.
// Only the 'IdMenu' 'IdRecette' fields are used.
func (item MenuRecette) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM menu_recettes WHERE 
	id_menu = $1 AND id_recette = $2;`, item.IdMenu, item.IdRecette)
	return err
}

func scanOneProduit(row scanner) (Produit, error) {
	var s Produit
	err := row.Scan(
		&s.Id,
		&s.IdLivraison,
		&s.Nom,
		&s.Conditionnement,
		&s.Prix,
		&s.ReferenceFournisseur,
		&s.Colisage,
	)
	return s, err
}

func ScanProduit(row *sql.Row) (Produit, error) {
	return scanOneProduit(row)
}

func SelectAllProduits(tx DB) (Produits, error) {
	rows, err := tx.Query("SELECT * FROM produits")
	if err != nil {
		return nil, err
	}
	return ScanProduits(rows)
}

// SelectProduit returns the entry matching id.
func SelectProduit(tx DB, id int64) (Produit, error) {
	row := tx.QueryRow("SELECT * FROM produits WHERE id = $1", id)
	return ScanProduit(row)
}

type Produits map[int64]Produit

func (m Produits) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanProduits(rs *sql.Rows) (Produits, error) {
	var (
		s   Produit
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Produits, 16)
	for rs.Next() {
		s, err = scanOneProduit(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Produit in the database and returns the item with id filled.
func (item Produit) Insert(tx DB) (out Produit, err error) {
	row := tx.QueryRow(`INSERT INTO produits (
		id_livraison,nom,conditionnement,prix,reference_fournisseur,colisage
		) VALUES (
		$1,$2,$3,$4,$5,$6
		) RETURNING 
		id,id_livraison,nom,conditionnement,prix,reference_fournisseur,colisage;
		`, item.IdLivraison, item.Nom, item.Conditionnement, item.Prix, item.ReferenceFournisseur, item.Colisage)
	return ScanProduit(row)
}

// Update Produit in the database and returns the new version.
func (item Produit) Update(tx DB) (out Produit, err error) {
	row := tx.QueryRow(`UPDATE produits SET (
		id_livraison,nom,conditionnement,prix,reference_fournisseur,colisage
		) = (
		$2,$3,$4,$5,$6,$7
		) WHERE id = $1 RETURNING 
		id,id_livraison,nom,conditionnement,prix,reference_fournisseur,colisage;
		`, item.Id, item.IdLivraison, item.Nom, item.Conditionnement, item.Prix, item.ReferenceFournisseur, item.Colisage)
	return ScanProduit(row)
}

// Deletes the Produit and returns the item
func DeleteProduitById(tx DB, id int64) (Produit, error) {
	row := tx.QueryRow("DELETE FROM produits WHERE id = $1 RETURNING *;", id)
	return ScanProduit(row)
}

// Deletes the Produit in the database and returns the ids.
func DeleteProduitsByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM produits WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneRecette(row scanner) (Recette, error) {
	var s Recette
	err := row.Scan(
		&s.Id,
		&s.IdUtilisateur,
		&s.Nom,
		&s.ModeEmploi,
	)
	return s, err
}

func ScanRecette(row *sql.Row) (Recette, error) {
	return scanOneRecette(row)
}

func SelectAllRecettes(tx DB) (Recettes, error) {
	rows, err := tx.Query("SELECT * FROM recettes")
	if err != nil {
		return nil, err
	}
	return ScanRecettes(rows)
}

// SelectRecette returns the entry matching id.
func SelectRecette(tx DB, id int64) (Recette, error) {
	row := tx.QueryRow("SELECT * FROM recettes WHERE id = $1", id)
	return ScanRecette(row)
}

type Recettes map[int64]Recette

func (m Recettes) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanRecettes(rs *sql.Rows) (Recettes, error) {
	var (
		s   Recette
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Recettes, 16)
	for rs.Next() {
		s, err = scanOneRecette(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Recette in the database and returns the item with id filled.
func (item Recette) Insert(tx DB) (out Recette, err error) {
	row := tx.QueryRow(`INSERT INTO recettes (
		id_utilisateur,nom,mode_emploi
		) VALUES (
		$1,$2,$3
		) RETURNING 
		id,id_utilisateur,nom,mode_emploi;
		`, item.IdUtilisateur, item.Nom, item.ModeEmploi)
	return ScanRecette(row)
}

// Update Recette in the database and returns the new version.
func (item Recette) Update(tx DB) (out Recette, err error) {
	row := tx.QueryRow(`UPDATE recettes SET (
		id_utilisateur,nom,mode_emploi
		) = (
		$2,$3,$4
		) WHERE id = $1 RETURNING 
		id,id_utilisateur,nom,mode_emploi;
		`, item.Id, item.IdUtilisateur, item.Nom, item.ModeEmploi)
	return ScanRecette(row)
}

// Deletes the Recette and returns the item
func DeleteRecetteById(tx DB, id int64) (Recette, error) {
	row := tx.QueryRow("DELETE FROM recettes WHERE id = $1 RETURNING *;", id)
	return ScanRecette(row)
}

// Deletes the Recette in the database and returns the ids.
func DeleteRecettesByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM recettes WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneRecetteIngredient(row scanner) (RecetteIngredient, error) {
	var s RecetteIngredient
	err := row.Scan(
		&s.IdRecette,
		&s.IdIngredient,
		&s.Quantite,
		&s.Cuisson,
	)
	return s, err
}

func ScanRecetteIngredient(row *sql.Row) (RecetteIngredient, error) {
	return scanOneRecetteIngredient(row)
}

func SelectAllRecetteIngredients(tx DB) (RecetteIngredients, error) {
	rows, err := tx.Query("SELECT * FROM recette_ingredients")
	if err != nil {
		return nil, err
	}
	return ScanRecetteIngredients(rows)
}

type RecetteIngredients []RecetteIngredient

func ScanRecetteIngredients(rs *sql.Rows) (RecetteIngredients, error) {
	var (
		s   RecetteIngredient
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(RecetteIngredients, 0, 16)
	for rs.Next() {
		s, err = scanOneRecetteIngredient(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links RecetteIngredient in the database.
func InsertManyRecetteIngredients(tx *sql.Tx, items ...RecetteIngredient) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("recette_ingredients",
		"id_recette", "id_ingredient", "quantite", "cuisson",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdRecette, item.IdIngredient, item.Quantite, item.Cuisson)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link RecetteIngredient in the database.
// Only the 'IdRecette' 'IdIngredient' fields are used.
func (item RecetteIngredient) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM recette_ingredients WHERE 
	id_recette = $1 AND id_ingredient = $2;`, item.IdRecette, item.IdIngredient)
	return err
}

func scanOneRepas(row scanner) (Repas, error) {
	var s Repas
	err := row.Scan(
		&s.Id,
		&s.IdSejour,
		&s.OffsetPersonnes,
		&s.JourOffset,
		&s.Horaire,
		&s.Anticipation,
	)
	return s, err
}

func ScanRepas(row *sql.Row) (Repas, error) {
	return scanOneRepas(row)
}

func SelectAllRepass(tx DB) (Repass, error) {
	rows, err := tx.Query("SELECT * FROM repass")
	if err != nil {
		return nil, err
	}
	return ScanRepass(rows)
}

// SelectRepas returns the entry matching id.
func SelectRepas(tx DB, id int64) (Repas, error) {
	row := tx.QueryRow("SELECT * FROM repass WHERE id = $1", id)
	return ScanRepas(row)
}

type Repass map[int64]Repas

func (m Repass) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanRepass(rs *sql.Rows) (Repass, error) {
	var (
		s   Repas
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Repass, 16)
	for rs.Next() {
		s, err = scanOneRepas(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Repas in the database and returns the item with id filled.
func (item Repas) Insert(tx DB) (out Repas, err error) {
	row := tx.QueryRow(`INSERT INTO repass (
		id_sejour,offset_personnes,jour_offset,horaire,anticipation
		) VALUES (
		$1,$2,$3,$4,$5
		) RETURNING 
		id,id_sejour,offset_personnes,jour_offset,horaire,anticipation;
		`, item.IdSejour, item.OffsetPersonnes, item.JourOffset, item.Horaire, item.Anticipation)
	return ScanRepas(row)
}

// Update Repas in the database and returns the new version.
func (item Repas) Update(tx DB) (out Repas, err error) {
	row := tx.QueryRow(`UPDATE repass SET (
		id_sejour,offset_personnes,jour_offset,horaire,anticipation
		) = (
		$2,$3,$4,$5,$6
		) WHERE id = $1 RETURNING 
		id,id_sejour,offset_personnes,jour_offset,horaire,anticipation;
		`, item.Id, item.IdSejour, item.OffsetPersonnes, item.JourOffset, item.Horaire, item.Anticipation)
	return ScanRepas(row)
}

// Deletes the Repas and returns the item
func DeleteRepasById(tx DB, id int64) (Repas, error) {
	row := tx.QueryRow("DELETE FROM repass WHERE id = $1 RETURNING *;", id)
	return ScanRepas(row)
}

// Deletes the Repas in the database and returns the ids.
func DeleteRepassByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM repass WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneRepasGroupe(row scanner) (RepasGroupe, error) {
	var s RepasGroupe
	err := row.Scan(
		&s.IdRepas,
		&s.IdGroupe,
	)
	return s, err
}

func ScanRepasGroupe(row *sql.Row) (RepasGroupe, error) {
	return scanOneRepasGroupe(row)
}

func SelectAllRepasGroupes(tx DB) (RepasGroupes, error) {
	rows, err := tx.Query("SELECT * FROM repas_groupes")
	if err != nil {
		return nil, err
	}
	return ScanRepasGroupes(rows)
}

type RepasGroupes []RepasGroupe

func ScanRepasGroupes(rs *sql.Rows) (RepasGroupes, error) {
	var (
		s   RepasGroupe
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(RepasGroupes, 0, 16)
	for rs.Next() {
		s, err = scanOneRepasGroupe(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links RepasGroupe in the database.
func InsertManyRepasGroupes(tx *sql.Tx, items ...RepasGroupe) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("repas_groupes",
		"id_repas", "id_groupe",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdRepas, item.IdGroupe)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link RepasGroupe in the database.
// Only the 'IdRepas' 'IdGroupe' fields are used.
func (item RepasGroupe) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM repas_groupes WHERE 
	id_repas = $1 AND id_groupe = $2;`, item.IdRepas, item.IdGroupe)
	return err
}

func scanOneRepasIngredient(row scanner) (RepasIngredient, error) {
	var s RepasIngredient
	err := row.Scan(
		&s.IdRepas,
		&s.IdIngredient,
		&s.Quantite,
		&s.Cuisson,
	)
	return s, err
}

func ScanRepasIngredient(row *sql.Row) (RepasIngredient, error) {
	return scanOneRepasIngredient(row)
}

func SelectAllRepasIngredients(tx DB) (RepasIngredients, error) {
	rows, err := tx.Query("SELECT * FROM repas_ingredients")
	if err != nil {
		return nil, err
	}
	return ScanRepasIngredients(rows)
}

type RepasIngredients []RepasIngredient

func ScanRepasIngredients(rs *sql.Rows) (RepasIngredients, error) {
	var (
		s   RepasIngredient
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(RepasIngredients, 0, 16)
	for rs.Next() {
		s, err = scanOneRepasIngredient(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links RepasIngredient in the database.
func InsertManyRepasIngredients(tx *sql.Tx, items ...RepasIngredient) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("repas_ingredients",
		"id_repas", "id_ingredient", "quantite", "cuisson",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdRepas, item.IdIngredient, item.Quantite, item.Cuisson)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link RepasIngredient in the database.
// Only the 'IdRepas' 'IdIngredient' fields are used.
func (item RepasIngredient) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM repas_ingredients WHERE 
	id_repas = $1 AND id_ingredient = $2;`, item.IdRepas, item.IdIngredient)
	return err
}

func scanOneRepasRecette(row scanner) (RepasRecette, error) {
	var s RepasRecette
	err := row.Scan(
		&s.IdRepas,
		&s.IdRecette,
	)
	return s, err
}

func ScanRepasRecette(row *sql.Row) (RepasRecette, error) {
	return scanOneRepasRecette(row)
}

func SelectAllRepasRecettes(tx DB) (RepasRecettes, error) {
	rows, err := tx.Query("SELECT * FROM repas_recettes")
	if err != nil {
		return nil, err
	}
	return ScanRepasRecettes(rows)
}

type RepasRecettes []RepasRecette

func ScanRepasRecettes(rs *sql.Rows) (RepasRecettes, error) {
	var (
		s   RepasRecette
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(RepasRecettes, 0, 16)
	for rs.Next() {
		s, err = scanOneRepasRecette(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links RepasRecette in the database.
func InsertManyRepasRecettes(tx *sql.Tx, items ...RepasRecette) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("repas_recettes",
		"id_repas", "id_recette",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdRepas, item.IdRecette)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link RepasRecette in the database.
// Only the 'IdRepas' 'IdRecette' fields are used.
func (item RepasRecette) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM repas_recettes WHERE 
	id_repas = $1 AND id_recette = $2;`, item.IdRepas, item.IdRecette)
	return err
}

func scanOneSejour(row scanner) (Sejour, error) {
	var s Sejour
	err := row.Scan(
		&s.Id,
		&s.IdUtilisateur,
		&s.DateDebut,
		&s.Nom,
	)
	return s, err
}

func ScanSejour(row *sql.Row) (Sejour, error) {
	return scanOneSejour(row)
}

func SelectAllSejours(tx DB) (Sejours, error) {
	rows, err := tx.Query("SELECT * FROM sejours")
	if err != nil {
		return nil, err
	}
	return ScanSejours(rows)
}

// SelectSejour returns the entry matching id.
func SelectSejour(tx DB, id int64) (Sejour, error) {
	row := tx.QueryRow("SELECT * FROM sejours WHERE id = $1", id)
	return ScanSejour(row)
}

type Sejours map[int64]Sejour

func (m Sejours) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanSejours(rs *sql.Rows) (Sejours, error) {
	var (
		s   Sejour
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Sejours, 16)
	for rs.Next() {
		s, err = scanOneSejour(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Sejour in the database and returns the item with id filled.
func (item Sejour) Insert(tx DB) (out Sejour, err error) {
	row := tx.QueryRow(`INSERT INTO sejours (
		id_utilisateur,date_debut,nom
		) VALUES (
		$1,$2,$3
		) RETURNING 
		id,id_utilisateur,date_debut,nom;
		`, item.IdUtilisateur, item.DateDebut, item.Nom)
	return ScanSejour(row)
}

// Update Sejour in the database and returns the new version.
func (item Sejour) Update(tx DB) (out Sejour, err error) {
	row := tx.QueryRow(`UPDATE sejours SET (
		id_utilisateur,date_debut,nom
		) = (
		$2,$3,$4
		) WHERE id = $1 RETURNING 
		id,id_utilisateur,date_debut,nom;
		`, item.Id, item.IdUtilisateur, item.DateDebut, item.Nom)
	return ScanSejour(row)
}

// Deletes the Sejour and returns the item
func DeleteSejourById(tx DB, id int64) (Sejour, error) {
	row := tx.QueryRow("DELETE FROM sejours WHERE id = $1 RETURNING *;", id)
	return ScanSejour(row)
}

// Deletes the Sejour in the database and returns the ids.
func DeleteSejoursByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM sejours WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneSejourFournisseur(row scanner) (SejourFournisseur, error) {
	var s SejourFournisseur
	err := row.Scan(
		&s.IdUtilisateur,
		&s.IdSejour,
		&s.IdFournisseur,
	)
	return s, err
}

func ScanSejourFournisseur(row *sql.Row) (SejourFournisseur, error) {
	return scanOneSejourFournisseur(row)
}

func SelectAllSejourFournisseurs(tx DB) (SejourFournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM sejour_fournisseurs")
	if err != nil {
		return nil, err
	}
	return ScanSejourFournisseurs(rows)
}

type SejourFournisseurs []SejourFournisseur

func ScanSejourFournisseurs(rs *sql.Rows) (SejourFournisseurs, error) {
	var (
		s   SejourFournisseur
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(SejourFournisseurs, 0, 16)
	for rs.Next() {
		s, err = scanOneSejourFournisseur(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links SejourFournisseur in the database.
func InsertManySejourFournisseurs(tx *sql.Tx, items ...SejourFournisseur) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("sejour_fournisseurs",
		"id_utilisateur", "id_sejour", "id_fournisseur",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdUtilisateur, item.IdSejour, item.IdFournisseur)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link SejourFournisseur in the database.
// Only the 'IdUtilisateur' 'IdSejour' 'IdFournisseur' fields are used.
func (item SejourFournisseur) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM sejour_fournisseurs WHERE 
	id_utilisateur = $1 AND id_sejour = $2 AND id_fournisseur = $3;`, item.IdUtilisateur, item.IdSejour, item.IdFournisseur)
	return err
}

func scanOneUtilisateur(row scanner) (Utilisateur, error) {
	var s Utilisateur
	err := row.Scan(
		&s.Id,
		&s.Password,
		&s.Mail,
		&s.PrenomNom,
	)
	return s, err
}

func ScanUtilisateur(row *sql.Row) (Utilisateur, error) {
	return scanOneUtilisateur(row)
}

func SelectAllUtilisateurs(tx DB) (Utilisateurs, error) {
	rows, err := tx.Query("SELECT * FROM utilisateurs")
	if err != nil {
		return nil, err
	}
	return ScanUtilisateurs(rows)
}

// SelectUtilisateur returns the entry matching id.
func SelectUtilisateur(tx DB, id int64) (Utilisateur, error) {
	row := tx.QueryRow("SELECT * FROM utilisateurs WHERE id = $1", id)
	return ScanUtilisateur(row)
}

type Utilisateurs map[int64]Utilisateur

func (m Utilisateurs) Ids() Ids {
	out := make(Ids, 0, len(m))
	for i := range m {
		out = append(out, i)
	}
	return out
}

func ScanUtilisateurs(rs *sql.Rows) (Utilisateurs, error) {
	var (
		s   Utilisateur
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(Utilisateurs, 16)
	for rs.Next() {
		s, err = scanOneUtilisateur(rs)
		if err != nil {
			return nil, err
		}
		structs[s.Id] = s
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert Utilisateur in the database and returns the item with id filled.
func (item Utilisateur) Insert(tx DB) (out Utilisateur, err error) {
	row := tx.QueryRow(`INSERT INTO utilisateurs (
		password,mail,prenom_nom
		) VALUES (
		$1,$2,$3
		) RETURNING 
		id,password,mail,prenom_nom;
		`, item.Password, item.Mail, item.PrenomNom)
	return ScanUtilisateur(row)
}

// Update Utilisateur in the database and returns the new version.
func (item Utilisateur) Update(tx DB) (out Utilisateur, err error) {
	row := tx.QueryRow(`UPDATE utilisateurs SET (
		password,mail,prenom_nom
		) = (
		$2,$3,$4
		) WHERE id = $1 RETURNING 
		id,password,mail,prenom_nom;
		`, item.Id, item.Password, item.Mail, item.PrenomNom)
	return ScanUtilisateur(row)
}

// Deletes the Utilisateur and returns the item
func DeleteUtilisateurById(tx DB, id int64) (Utilisateur, error) {
	row := tx.QueryRow("DELETE FROM utilisateurs WHERE id = $1 RETURNING *;", id)
	return ScanUtilisateur(row)
}

// Deletes the Utilisateur in the database and returns the ids.
func DeleteUtilisateursByIds(tx DB, ids ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM utilisateurs WHERE id = ANY($1) RETURNING id", pq.Int64Array(ids))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func scanOneUtilisateurFournisseur(row scanner) (UtilisateurFournisseur, error) {
	var s UtilisateurFournisseur
	err := row.Scan(
		&s.IdUtilisateur,
		&s.IdFournisseur,
	)
	return s, err
}

func ScanUtilisateurFournisseur(row *sql.Row) (UtilisateurFournisseur, error) {
	return scanOneUtilisateurFournisseur(row)
}

func SelectAllUtilisateurFournisseurs(tx DB) (UtilisateurFournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM utilisateur_fournisseurs")
	if err != nil {
		return nil, err
	}
	return ScanUtilisateurFournisseurs(rows)
}

type UtilisateurFournisseurs []UtilisateurFournisseur

func ScanUtilisateurFournisseurs(rs *sql.Rows) (UtilisateurFournisseurs, error) {
	var (
		s   UtilisateurFournisseur
		err error
	)
	defer func() {
		errClose := rs.Close()
		if err == nil {
			err = errClose
		}
	}()
	structs := make(UtilisateurFournisseurs, 0, 16)
	for rs.Next() {
		s, err = scanOneUtilisateurFournisseur(rs)
		if err != nil {
			return nil, err
		}
		structs = append(structs, s)
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}

// Insert the links UtilisateurFournisseur in the database.
func InsertManyUtilisateurFournisseurs(tx *sql.Tx, items ...UtilisateurFournisseur) error {
	if len(items) == 0 {
		return nil
	}

	stmt, err := tx.Prepare(pq.CopyIn("utilisateur_fournisseurs",
		"id_utilisateur", "id_fournisseur",
	))
	if err != nil {
		return err
	}

	for _, item := range items {
		_, err = stmt.Exec(item.IdUtilisateur, item.IdFournisseur)
		if err != nil {
			return err
		}
	}

	if _, err = stmt.Exec(); err != nil {
		return err
	}

	if err = stmt.Close(); err != nil {
		return err
	}
	return nil
}

// Delete the link UtilisateurFournisseur in the database.
// Only the 'IdUtilisateur' 'IdFournisseur' fields are used.
func (item UtilisateurFournisseur) Delete(tx DB) error {
	_, err := tx.Exec(`DELETE FROM utilisateur_fournisseurs WHERE 
	id_utilisateur = $1 AND id_fournisseur = $2;`, item.IdUtilisateur, item.IdFournisseur)
	return err
}

func SelectCommandesByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Commandes, error) {
	rows, err := tx.Query("SELECT * FROM commandes WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanCommandes(rows)
}

func DeleteCommandesByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM commandes WHERE id_utilisateur = ANY($1) RETURNING id", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectCommandeProduitsByIdCommandes(tx DB, idCommandes ...int64) (CommandeProduits, error) {
	rows, err := tx.Query("SELECT * FROM commande_produits WHERE id_commande = ANY($1)", pq.Int64Array(idCommandes))
	if err != nil {
		return nil, err
	}
	return ScanCommandeProduits(rows)
}

func DeleteCommandeProduitsByIdCommandes(tx DB, idCommandes ...int64) error {
	_, err := tx.Exec("DELETE FROM commande_produits WHERE id_commande = ANY($1)", pq.Int64Array(idCommandes))
	return err
}

func SelectCommandeProduitsByIdProduits(tx DB, idProduits ...int64) (CommandeProduits, error) {
	rows, err := tx.Query("SELECT * FROM commande_produits WHERE id_produit = ANY($1)", pq.Int64Array(idProduits))
	if err != nil {
		return nil, err
	}
	return ScanCommandeProduits(rows)
}

func DeleteCommandeProduitsByIdProduits(tx DB, idProduits ...int64) error {
	_, err := tx.Exec("DELETE FROM commande_produits WHERE id_produit = ANY($1)", pq.Int64Array(idProduits))
	return err
}

// ByIdCommande returns a map with 'IdCommande' as keys.
func (items CommandeProduits) ByIdCommande() map[int64]CommandeProduits {
	out := make(map[int64]CommandeProduits)
	for _, target := range items {
		out[target.IdCommande] = append(out[target.IdCommande], target)
	}
	return out
}

// ByIdProduit returns a map with 'IdProduit' as keys.
func (items CommandeProduits) ByIdProduit() map[int64]CommandeProduits {
	out := make(map[int64]CommandeProduits)
	for _, target := range items {
		out[target.IdProduit] = append(out[target.IdProduit], target)
	}
	return out
}

func SelectDefautProduitsByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (DefautProduits, error) {
	rows, err := tx.Query("SELECT * FROM defaut_produits WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanDefautProduits(rows)
}

func DeleteDefautProduitsByIdUtilisateurs(tx DB, idUtilisateurs ...int64) error {
	_, err := tx.Exec("DELETE FROM defaut_produits WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	return err
}

func SelectDefautProduitsByIdIngredients(tx DB, idIngredients ...int64) (DefautProduits, error) {
	rows, err := tx.Query("SELECT * FROM defaut_produits WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	if err != nil {
		return nil, err
	}
	return ScanDefautProduits(rows)
}

func DeleteDefautProduitsByIdIngredients(tx DB, idIngredients ...int64) error {
	_, err := tx.Exec("DELETE FROM defaut_produits WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	return err
}

func SelectDefautProduitsByIdFournisseurs(tx DB, idFournisseurs ...int64) (DefautProduits, error) {
	rows, err := tx.Query("SELECT * FROM defaut_produits WHERE id_fournisseur = ANY($1)", pq.Int64Array(idFournisseurs))
	if err != nil {
		return nil, err
	}
	return ScanDefautProduits(rows)
}

func DeleteDefautProduitsByIdFournisseurs(tx DB, idFournisseurs ...int64) error {
	_, err := tx.Exec("DELETE FROM defaut_produits WHERE id_fournisseur = ANY($1)", pq.Int64Array(idFournisseurs))
	return err
}

func SelectDefautProduitsByIdProduits(tx DB, idProduits ...int64) (DefautProduits, error) {
	rows, err := tx.Query("SELECT * FROM defaut_produits WHERE id_produit = ANY($1)", pq.Int64Array(idProduits))
	if err != nil {
		return nil, err
	}
	return ScanDefautProduits(rows)
}

func DeleteDefautProduitsByIdProduits(tx DB, idProduits ...int64) error {
	_, err := tx.Exec("DELETE FROM defaut_produits WHERE id_produit = ANY($1)", pq.Int64Array(idProduits))
	return err
}

// ByIdUtilisateur returns a map with 'IdUtilisateur' as keys.
func (items DefautProduits) ByIdUtilisateur() map[int64]DefautProduits {
	out := make(map[int64]DefautProduits)
	for _, target := range items {
		out[target.IdUtilisateur] = append(out[target.IdUtilisateur], target)
	}
	return out
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items DefautProduits) ByIdIngredient() map[int64]DefautProduits {
	out := make(map[int64]DefautProduits)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

// ByIdFournisseur returns a map with 'IdFournisseur' as keys.
func (items DefautProduits) ByIdFournisseur() map[int64]DefautProduits {
	out := make(map[int64]DefautProduits)
	for _, target := range items {
		out[target.IdFournisseur] = append(out[target.IdFournisseur], target)
	}
	return out
}

// ByIdProduit returns a map with 'IdProduit' as keys.
func (items DefautProduits) ByIdProduit() map[int64]DefautProduits {
	out := make(map[int64]DefautProduits)
	for _, target := range items {
		out[target.IdProduit] = append(out[target.IdProduit], target)
	}
	return out
}

func SelectGroupesByIdSejours(tx DB, idSejours ...int64) (Groupes, error) {
	rows, err := tx.Query("SELECT * FROM groupes WHERE id_sejour = ANY($1)", pq.Int64Array(idSejours))
	if err != nil {
		return nil, err
	}
	return ScanGroupes(rows)
}

func DeleteGroupesByIdSejours(tx DB, idSejours ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM groupes WHERE id_sejour = ANY($1) RETURNING id", pq.Int64Array(idSejours))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectIngredientProduitsByIdIngredients(tx DB, idIngredients ...int64) (IngredientProduits, error) {
	rows, err := tx.Query("SELECT * FROM ingredient_produits WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	if err != nil {
		return nil, err
	}
	return ScanIngredientProduits(rows)
}

func DeleteIngredientProduitsByIdIngredients(tx DB, idIngredients ...int64) error {
	_, err := tx.Exec("DELETE FROM ingredient_produits WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	return err
}

func SelectIngredientProduitsByIdProduits(tx DB, idProduits ...int64) (IngredientProduits, error) {
	rows, err := tx.Query("SELECT * FROM ingredient_produits WHERE id_produit = ANY($1)", pq.Int64Array(idProduits))
	if err != nil {
		return nil, err
	}
	return ScanIngredientProduits(rows)
}

func DeleteIngredientProduitsByIdProduits(tx DB, idProduits ...int64) error {
	_, err := tx.Exec("DELETE FROM ingredient_produits WHERE id_produit = ANY($1)", pq.Int64Array(idProduits))
	return err
}

func SelectIngredientProduitsByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (IngredientProduits, error) {
	rows, err := tx.Query("SELECT * FROM ingredient_produits WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanIngredientProduits(rows)
}

func DeleteIngredientProduitsByIdUtilisateurs(tx DB, idUtilisateurs ...int64) error {
	_, err := tx.Exec("DELETE FROM ingredient_produits WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	return err
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items IngredientProduits) ByIdIngredient() map[int64]IngredientProduits {
	out := make(map[int64]IngredientProduits)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

// ByIdProduit returns a map with 'IdProduit' as keys.
func (items IngredientProduits) ByIdProduit() map[int64]IngredientProduits {
	out := make(map[int64]IngredientProduits)
	for _, target := range items {
		out[target.IdProduit] = append(out[target.IdProduit], target)
	}
	return out
}

// ByIdUtilisateur returns a map with 'IdUtilisateur' as keys.
func (items IngredientProduits) ByIdUtilisateur() map[int64]IngredientProduits {
	out := make(map[int64]IngredientProduits)
	for _, target := range items {
		out[target.IdUtilisateur] = append(out[target.IdUtilisateur], target)
	}
	return out
}

func SelectLienIngredientsByIdIngredients(tx DB, idIngredients ...int64) (LienIngredients, error) {
	rows, err := tx.Query("SELECT * FROM lien_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	if err != nil {
		return nil, err
	}
	return ScanLienIngredients(rows)
}

func DeleteLienIngredientsByIdIngredients(tx DB, idIngredients ...int64) error {
	_, err := tx.Exec("DELETE FROM lien_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	return err
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items LienIngredients) ByIdIngredient() map[int64]LienIngredients {
	out := make(map[int64]LienIngredients)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

func SelectLivraisonsByIdFournisseurs(tx DB, idFournisseurs ...int64) (Livraisons, error) {
	rows, err := tx.Query("SELECT * FROM livraisons WHERE id_fournisseur = ANY($1)", pq.Int64Array(idFournisseurs))
	if err != nil {
		return nil, err
	}
	return ScanLivraisons(rows)
}

func DeleteLivraisonsByIdFournisseurs(tx DB, idFournisseurs ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM livraisons WHERE id_fournisseur = ANY($1) RETURNING id", pq.Int64Array(idFournisseurs))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectMenusByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Menus, error) {
	rows, err := tx.Query("SELECT * FROM menus WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanMenus(rows)
}

func DeleteMenusByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM menus WHERE id_utilisateur = ANY($1) RETURNING id", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectMenuIngredientsByIdMenus(tx DB, idMenus ...int64) (MenuIngredients, error) {
	rows, err := tx.Query("SELECT * FROM menu_ingredients WHERE id_menu = ANY($1)", pq.Int64Array(idMenus))
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

func DeleteMenuIngredientsByIdMenus(tx DB, idMenus ...int64) error {
	_, err := tx.Exec("DELETE FROM menu_ingredients WHERE id_menu = ANY($1)", pq.Int64Array(idMenus))
	return err
}

func SelectMenuIngredientsByIdIngredients(tx DB, idIngredients ...int64) (MenuIngredients, error) {
	rows, err := tx.Query("SELECT * FROM menu_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	if err != nil {
		return nil, err
	}
	return ScanMenuIngredients(rows)
}

func DeleteMenuIngredientsByIdIngredients(tx DB, idIngredients ...int64) error {
	_, err := tx.Exec("DELETE FROM menu_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	return err
}

// ByIdMenu returns a map with 'IdMenu' as keys.
func (items MenuIngredients) ByIdMenu() map[int64]MenuIngredients {
	out := make(map[int64]MenuIngredients)
	for _, target := range items {
		out[target.IdMenu] = append(out[target.IdMenu], target)
	}
	return out
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items MenuIngredients) ByIdIngredient() map[int64]MenuIngredients {
	out := make(map[int64]MenuIngredients)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

func SelectMenuRecettesByIdMenus(tx DB, idMenus ...int64) (MenuRecettes, error) {
	rows, err := tx.Query("SELECT * FROM menu_recettes WHERE id_menu = ANY($1)", pq.Int64Array(idMenus))
	if err != nil {
		return nil, err
	}
	return ScanMenuRecettes(rows)
}

func DeleteMenuRecettesByIdMenus(tx DB, idMenus ...int64) error {
	_, err := tx.Exec("DELETE FROM menu_recettes WHERE id_menu = ANY($1)", pq.Int64Array(idMenus))
	return err
}

func SelectMenuRecettesByIdRecettes(tx DB, idRecettes ...int64) (MenuRecettes, error) {
	rows, err := tx.Query("SELECT * FROM menu_recettes WHERE id_recette = ANY($1)", pq.Int64Array(idRecettes))
	if err != nil {
		return nil, err
	}
	return ScanMenuRecettes(rows)
}

func DeleteMenuRecettesByIdRecettes(tx DB, idRecettes ...int64) error {
	_, err := tx.Exec("DELETE FROM menu_recettes WHERE id_recette = ANY($1)", pq.Int64Array(idRecettes))
	return err
}

// ByIdMenu returns a map with 'IdMenu' as keys.
func (items MenuRecettes) ByIdMenu() map[int64]MenuRecettes {
	out := make(map[int64]MenuRecettes)
	for _, target := range items {
		out[target.IdMenu] = append(out[target.IdMenu], target)
	}
	return out
}

// ByIdRecette returns a map with 'IdRecette' as keys.
func (items MenuRecettes) ByIdRecette() map[int64]MenuRecettes {
	out := make(map[int64]MenuRecettes)
	for _, target := range items {
		out[target.IdRecette] = append(out[target.IdRecette], target)
	}
	return out
}

func SelectProduitsByIdLivraisons(tx DB, idLivraisons ...int64) (Produits, error) {
	rows, err := tx.Query("SELECT * FROM produits WHERE id_livraison = ANY($1)", pq.Int64Array(idLivraisons))
	if err != nil {
		return nil, err
	}
	return ScanProduits(rows)
}

func DeleteProduitsByIdLivraisons(tx DB, idLivraisons ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM produits WHERE id_livraison = ANY($1) RETURNING id", pq.Int64Array(idLivraisons))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectRecettesByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Recettes, error) {
	rows, err := tx.Query("SELECT * FROM recettes WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanRecettes(rows)
}

func DeleteRecettesByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM recettes WHERE id_utilisateur = ANY($1) RETURNING id", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectRecetteIngredientsByIdRecettes(tx DB, idRecettes ...int64) (RecetteIngredients, error) {
	rows, err := tx.Query("SELECT * FROM recette_ingredients WHERE id_recette = ANY($1)", pq.Int64Array(idRecettes))
	if err != nil {
		return nil, err
	}
	return ScanRecetteIngredients(rows)
}

func DeleteRecetteIngredientsByIdRecettes(tx DB, idRecettes ...int64) error {
	_, err := tx.Exec("DELETE FROM recette_ingredients WHERE id_recette = ANY($1)", pq.Int64Array(idRecettes))
	return err
}

func SelectRecetteIngredientsByIdIngredients(tx DB, idIngredients ...int64) (RecetteIngredients, error) {
	rows, err := tx.Query("SELECT * FROM recette_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	if err != nil {
		return nil, err
	}
	return ScanRecetteIngredients(rows)
}

func DeleteRecetteIngredientsByIdIngredients(tx DB, idIngredients ...int64) error {
	_, err := tx.Exec("DELETE FROM recette_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	return err
}

// ByIdRecette returns a map with 'IdRecette' as keys.
func (items RecetteIngredients) ByIdRecette() map[int64]RecetteIngredients {
	out := make(map[int64]RecetteIngredients)
	for _, target := range items {
		out[target.IdRecette] = append(out[target.IdRecette], target)
	}
	return out
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items RecetteIngredients) ByIdIngredient() map[int64]RecetteIngredients {
	out := make(map[int64]RecetteIngredients)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

func SelectRepassByIdSejours(tx DB, idSejours ...int64) (Repass, error) {
	rows, err := tx.Query("SELECT * FROM repass WHERE id_sejour = ANY($1)", pq.Int64Array(idSejours))
	if err != nil {
		return nil, err
	}
	return ScanRepass(rows)
}

func DeleteRepassByIdSejours(tx DB, idSejours ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM repass WHERE id_sejour = ANY($1) RETURNING id", pq.Int64Array(idSejours))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectRepasGroupesByIdRepass(tx DB, idRepass ...int64) (RepasGroupes, error) {
	rows, err := tx.Query("SELECT * FROM repas_groupes WHERE id_repas = ANY($1)", pq.Int64Array(idRepass))
	if err != nil {
		return nil, err
	}
	return ScanRepasGroupes(rows)
}

func DeleteRepasGroupesByIdRepass(tx DB, idRepass ...int64) error {
	_, err := tx.Exec("DELETE FROM repas_groupes WHERE id_repas = ANY($1)", pq.Int64Array(idRepass))
	return err
}

func SelectRepasGroupesByIdGroupes(tx DB, idGroupes ...int64) (RepasGroupes, error) {
	rows, err := tx.Query("SELECT * FROM repas_groupes WHERE id_groupe = ANY($1)", pq.Int64Array(idGroupes))
	if err != nil {
		return nil, err
	}
	return ScanRepasGroupes(rows)
}

func DeleteRepasGroupesByIdGroupes(tx DB, idGroupes ...int64) error {
	_, err := tx.Exec("DELETE FROM repas_groupes WHERE id_groupe = ANY($1)", pq.Int64Array(idGroupes))
	return err
}

// ByIdRepas returns a map with 'IdRepas' as keys.
func (items RepasGroupes) ByIdRepas() map[int64]RepasGroupes {
	out := make(map[int64]RepasGroupes)
	for _, target := range items {
		out[target.IdRepas] = append(out[target.IdRepas], target)
	}
	return out
}

// ByIdGroupe returns a map with 'IdGroupe' as keys.
func (items RepasGroupes) ByIdGroupe() map[int64]RepasGroupes {
	out := make(map[int64]RepasGroupes)
	for _, target := range items {
		out[target.IdGroupe] = append(out[target.IdGroupe], target)
	}
	return out
}

func SelectRepasIngredientsByIdRepass(tx DB, idRepass ...int64) (RepasIngredients, error) {
	rows, err := tx.Query("SELECT * FROM repas_ingredients WHERE id_repas = ANY($1)", pq.Int64Array(idRepass))
	if err != nil {
		return nil, err
	}
	return ScanRepasIngredients(rows)
}

func DeleteRepasIngredientsByIdRepass(tx DB, idRepass ...int64) error {
	_, err := tx.Exec("DELETE FROM repas_ingredients WHERE id_repas = ANY($1)", pq.Int64Array(idRepass))
	return err
}

func SelectRepasIngredientsByIdIngredients(tx DB, idIngredients ...int64) (RepasIngredients, error) {
	rows, err := tx.Query("SELECT * FROM repas_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	if err != nil {
		return nil, err
	}
	return ScanRepasIngredients(rows)
}

func DeleteRepasIngredientsByIdIngredients(tx DB, idIngredients ...int64) error {
	_, err := tx.Exec("DELETE FROM repas_ingredients WHERE id_ingredient = ANY($1)", pq.Int64Array(idIngredients))
	return err
}

// ByIdRepas returns a map with 'IdRepas' as keys.
func (items RepasIngredients) ByIdRepas() map[int64]RepasIngredients {
	out := make(map[int64]RepasIngredients)
	for _, target := range items {
		out[target.IdRepas] = append(out[target.IdRepas], target)
	}
	return out
}

// ByIdIngredient returns a map with 'IdIngredient' as keys.
func (items RepasIngredients) ByIdIngredient() map[int64]RepasIngredients {
	out := make(map[int64]RepasIngredients)
	for _, target := range items {
		out[target.IdIngredient] = append(out[target.IdIngredient], target)
	}
	return out
}

func SelectRepasRecettesByIdRepass(tx DB, idRepass ...int64) (RepasRecettes, error) {
	rows, err := tx.Query("SELECT * FROM repas_recettes WHERE id_repas = ANY($1)", pq.Int64Array(idRepass))
	if err != nil {
		return nil, err
	}
	return ScanRepasRecettes(rows)
}

func DeleteRepasRecettesByIdRepass(tx DB, idRepass ...int64) error {
	_, err := tx.Exec("DELETE FROM repas_recettes WHERE id_repas = ANY($1)", pq.Int64Array(idRepass))
	return err
}

func SelectRepasRecettesByIdRecettes(tx DB, idRecettes ...int64) (RepasRecettes, error) {
	rows, err := tx.Query("SELECT * FROM repas_recettes WHERE id_recette = ANY($1)", pq.Int64Array(idRecettes))
	if err != nil {
		return nil, err
	}
	return ScanRepasRecettes(rows)
}

func DeleteRepasRecettesByIdRecettes(tx DB, idRecettes ...int64) error {
	_, err := tx.Exec("DELETE FROM repas_recettes WHERE id_recette = ANY($1)", pq.Int64Array(idRecettes))
	return err
}

// ByIdRepas returns a map with 'IdRepas' as keys.
func (items RepasRecettes) ByIdRepas() map[int64]RepasRecettes {
	out := make(map[int64]RepasRecettes)
	for _, target := range items {
		out[target.IdRepas] = append(out[target.IdRepas], target)
	}
	return out
}

// ByIdRecette returns a map with 'IdRecette' as keys.
func (items RepasRecettes) ByIdRecette() map[int64]RepasRecettes {
	out := make(map[int64]RepasRecettes)
	for _, target := range items {
		out[target.IdRecette] = append(out[target.IdRecette], target)
	}
	return out
}

func SelectSejoursByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Sejours, error) {
	rows, err := tx.Query("SELECT * FROM sejours WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanSejours(rows)
}

func DeleteSejoursByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (Ids, error) {
	rows, err := tx.Query("DELETE FROM sejours WHERE id_utilisateur = ANY($1) RETURNING id", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanIds(rows)
}

func SelectSejourFournisseursByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (SejourFournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM sejour_fournisseurs WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanSejourFournisseurs(rows)
}

func DeleteSejourFournisseursByIdUtilisateurs(tx DB, idUtilisateurs ...int64) error {
	_, err := tx.Exec("DELETE FROM sejour_fournisseurs WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	return err
}

func SelectSejourFournisseursByIdSejours(tx DB, idSejours ...int64) (SejourFournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM sejour_fournisseurs WHERE id_sejour = ANY($1)", pq.Int64Array(idSejours))
	if err != nil {
		return nil, err
	}
	return ScanSejourFournisseurs(rows)
}

func DeleteSejourFournisseursByIdSejours(tx DB, idSejours ...int64) error {
	_, err := tx.Exec("DELETE FROM sejour_fournisseurs WHERE id_sejour = ANY($1)", pq.Int64Array(idSejours))
	return err
}

func SelectSejourFournisseursByIdFournisseurs(tx DB, idFournisseurs ...int64) (SejourFournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM sejour_fournisseurs WHERE id_fournisseur = ANY($1)", pq.Int64Array(idFournisseurs))
	if err != nil {
		return nil, err
	}
	return ScanSejourFournisseurs(rows)
}

func DeleteSejourFournisseursByIdFournisseurs(tx DB, idFournisseurs ...int64) error {
	_, err := tx.Exec("DELETE FROM sejour_fournisseurs WHERE id_fournisseur = ANY($1)", pq.Int64Array(idFournisseurs))
	return err
}

// ByIdUtilisateur returns a map with 'IdUtilisateur' as keys.
func (items SejourFournisseurs) ByIdUtilisateur() map[int64]SejourFournisseurs {
	out := make(map[int64]SejourFournisseurs)
	for _, target := range items {
		out[target.IdUtilisateur] = append(out[target.IdUtilisateur], target)
	}
	return out
}

// ByIdSejour returns a map with 'IdSejour' as keys.
func (items SejourFournisseurs) ByIdSejour() map[int64]SejourFournisseurs {
	out := make(map[int64]SejourFournisseurs)
	for _, target := range items {
		out[target.IdSejour] = append(out[target.IdSejour], target)
	}
	return out
}

// ByIdFournisseur returns a map with 'IdFournisseur' as keys.
func (items SejourFournisseurs) ByIdFournisseur() map[int64]SejourFournisseurs {
	out := make(map[int64]SejourFournisseurs)
	for _, target := range items {
		out[target.IdFournisseur] = append(out[target.IdFournisseur], target)
	}
	return out
}

func SelectUtilisateurFournisseursByIdUtilisateurs(tx DB, idUtilisateurs ...int64) (UtilisateurFournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM utilisateur_fournisseurs WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	if err != nil {
		return nil, err
	}
	return ScanUtilisateurFournisseurs(rows)
}

func DeleteUtilisateurFournisseursByIdUtilisateurs(tx DB, idUtilisateurs ...int64) error {
	_, err := tx.Exec("DELETE FROM utilisateur_fournisseurs WHERE id_utilisateur = ANY($1)", pq.Int64Array(idUtilisateurs))
	return err
}

func SelectUtilisateurFournisseursByIdFournisseurs(tx DB, idFournisseurs ...int64) (UtilisateurFournisseurs, error) {
	rows, err := tx.Query("SELECT * FROM utilisateur_fournisseurs WHERE id_fournisseur = ANY($1)", pq.Int64Array(idFournisseurs))
	if err != nil {
		return nil, err
	}
	return ScanUtilisateurFournisseurs(rows)
}

func DeleteUtilisateurFournisseursByIdFournisseurs(tx DB, idFournisseurs ...int64) error {
	_, err := tx.Exec("DELETE FROM utilisateur_fournisseurs WHERE id_fournisseur = ANY($1)", pq.Int64Array(idFournisseurs))
	return err
}

// ByIdUtilisateur returns a map with 'IdUtilisateur' as keys.
func (items UtilisateurFournisseurs) ByIdUtilisateur() map[int64]UtilisateurFournisseurs {
	out := make(map[int64]UtilisateurFournisseurs)
	for _, target := range items {
		out[target.IdUtilisateur] = append(out[target.IdUtilisateur], target)
	}
	return out
}

// ByIdFournisseur returns a map with 'IdFournisseur' as keys.
func (items UtilisateurFournisseurs) ByIdFournisseur() map[int64]UtilisateurFournisseurs {
	out := make(map[int64]UtilisateurFournisseurs)
	for _, target := range items {
		out[target.IdFournisseur] = append(out[target.IdFournisseur], target)
	}
	return out
}
